// tests/utils/test-helpers.js\n// Utility functions and helpers for ICRS SPARC testing\n\nimport { mockUsers, mockPreadmissions, mockPreshipments } from '../fixtures/dock-audit-test-data.js';\n\n/**\n * Database testing utilities\n */\nexport const dbUtils = {\n  /**\n   * Reset database to clean state for testing\n   */\n  async resetDatabase() {\n    // This would connect to test database and clean all tables\n    // Implementation depends on your database setup\n    const tables = [\n      'transactions',\n      'inventory_locations', \n      'inventory_lots',\n      'preshipment_line_items',\n      'preadmission_items',\n      'preshipments',\n      'preadmissions',\n      'users'\n    ];\n\n    for (const table of tables) {\n      await this.truncateTable(table);\n    }\n  },\n\n  /**\n   * Truncate a specific table\n   */\n  async truncateTable(tableName) {\n    // Mock implementation - replace with actual database calls\n    console.log(`Truncating table: ${tableName}`);\n  },\n\n  /**\n   * Seed database with test data\n   */\n  async seedDatabase(data = {}) {\n    const {\n      users = [mockUsers.dockAuditor, mockUsers.shippingCoordinator],\n      preadmissions = [mockPreadmissions.basic, mockPreadmissions.withDiscrepancy],\n      preshipments = [mockPreshipments.draft, mockPreshipments.readyToFile]\n    } = data;\n\n    // Insert test data in correct order (respecting foreign keys)\n    await this.insertTestData('users', users);\n    await this.insertTestData('preadmissions', preadmissions);\n    await this.insertTestData('preshipments', preshipments);\n    \n    return {\n      users: users.length,\n      preadmissions: preadmissions.length,\n      preshipments: preshipments.length\n    };\n  },\n\n  /**\n   * Insert test data into specific table\n   */\n  async insertTestData(tableName, data) {\n    if (!Array.isArray(data) || data.length === 0) return;\n    \n    console.log(`Inserting ${data.length} records into ${tableName}`);\n    // Mock implementation - replace with actual database inserts\n  },\n\n  /**\n   * Create a test transaction wrapper\n   */\n  async withTransaction(callback) {\n    // Mock implementation - in real app, would wrap in DB transaction\n    try {\n      console.log('Starting test transaction');\n      const result = await callback();\n      console.log('Committing test transaction');\n      return result;\n    } catch (error) {\n      console.log('Rolling back test transaction');\n      throw error;\n    }\n  }\n};\n\n/**\n * Authentication testing utilities\n */\nexport const authUtils = {\n  /**\n   * Generate a test JWT token\n   */\n  generateTestToken(user = mockUsers.dockAuditor, expiresIn = '1h') {\n    // Mock JWT - in real app, use actual JWT library\n    const header = Buffer.from(JSON.stringify({ alg: 'HS256', typ: 'JWT' })).toString('base64');\n    const payload = Buffer.from(JSON.stringify({\n      id: user.id,\n      username: user.username,\n      role: user.role,\n      permissions: user.permissions,\n      exp: Math.floor(Date.now() / 1000) + (60 * 60) // 1 hour\n    })).toString('base64');\n    const signature = 'mock-signature';\n    \n    return `${header}.${payload}.${signature}`;\n  },\n\n  /**\n   * Create authorization headers for API tests\n   */\n  createAuthHeaders(user = mockUsers.dockAuditor) {\n    return {\n      'Authorization': `Bearer ${this.generateTestToken(user)}`,\n      'Content-Type': 'application/json'\n    };\n  },\n\n  /**\n   * Mock user session for frontend tests\n   */\n  mockUserSession(user = mockUsers.dockAuditor) {\n    return {\n      user,\n      token: this.generateTestToken(user),\n      isAuthenticated: true,\n      expiresAt: new Date(Date.now() + 60 * 60 * 1000).toISOString()\n    };\n  },\n\n  /**\n   * Check if user has required permission\n   */\n  hasPermission(user, permission) {\n    if (user.permissions.includes('*:*')) return true; // Admin access\n    return user.permissions.includes(permission);\n  }\n};\n\n/**\n * File upload testing utilities\n */\nexport const fileUtils = {\n  /**\n   * Create a mock File object for testing\n   */\n  createMockFile(name, type = 'image/jpeg', size = 1024, content = 'mock-content') {\n    const blob = new Blob([content], { type });\n    const file = new File([blob], name, { type, lastModified: Date.now() });\n    \n    // Add mock methods for testing\n    file.arrayBuffer = jest.fn().mockResolvedValue(new ArrayBuffer(size));\n    file.text = jest.fn().mockResolvedValue(content);\n    \n    return file;\n  },\n\n  /**\n   * Create multiple mock files\n   */\n  createMockFiles(count = 3, namePrefix = 'test-image') {\n    return Array.from({ length: count }, (_, index) => \n      this.createMockFile(\n        `${namePrefix}-${index + 1}.jpg`,\n        'image/jpeg',\n        1024 * (index + 1)\n      )\n    );\n  },\n\n  /**\n   * Mock FileReader for testing\n   */\n  mockFileReader(result = 'data:image/jpeg;base64,mock-data') {\n    const mockFileReader = {\n      readAsDataURL: jest.fn(function() {\n        this.result = result;\n        setTimeout(() => this.onload?.(), 0);\n      }),\n      readAsArrayBuffer: jest.fn(function() {\n        this.result = new ArrayBuffer(8);\n        setTimeout(() => this.onload?.(), 0);\n      }),\n      abort: jest.fn(),\n      result: null,\n      error: null,\n      onload: null,\n      onerror: null,\n      onabort: null\n    };\n    \n    global.FileReader = jest.fn(() => mockFileReader);\n    return mockFileReader;\n  },\n\n  /**\n   * Validate file type and size\n   */\n  validateFile(file, allowedTypes = ['image/jpeg', 'image/png'], maxSize = 5 * 1024 * 1024) {\n    const errors = [];\n    \n    if (!allowedTypes.includes(file.type)) {\n      errors.push(`File type ${file.type} not allowed. Allowed types: ${allowedTypes.join(', ')}`);\n    }\n    \n    if (file.size > maxSize) {\n      errors.push(`File size ${file.size} exceeds maximum ${maxSize} bytes`);\n    }\n    \n    return {\n      isValid: errors.length === 0,\n      errors\n    };\n  }\n};\n\n/**\n * API testing utilities\n */\nexport const apiUtils = {\n  /**\n   * Create mock API response\n   */\n  createMockResponse(data, status = 200, headers = {}) {\n    return {\n      ok: status >= 200 && status < 300,\n      status,\n      statusText: status === 200 ? 'OK' : 'Error',\n      headers: new Map(Object.entries(headers)),\n      json: jest.fn().mockResolvedValue(data),\n      text: jest.fn().mockResolvedValue(JSON.stringify(data)),\n      blob: jest.fn().mockResolvedValue(new Blob([JSON.stringify(data)]))\n    };\n  },\n\n  /**\n   * Mock fetch for API tests\n   */\n  mockFetch(responses = {}) {\n    global.fetch = jest.fn((url, options) => {\n      const method = options?.method || 'GET';\n      const key = `${method} ${url}`;\n      \n      if (responses[key]) {\n        return Promise.resolve(responses[key]);\n      }\n      \n      if (responses[url]) {\n        return Promise.resolve(responses[url]);\n      }\n      \n      // Default success response\n      return Promise.resolve(this.createMockResponse({ success: true }));\n    });\n  },\n\n  /**\n   * Create API error response\n   */\n  createErrorResponse(message = 'Test error', status = 500, code = 'TEST_ERROR') {\n    return this.createMockResponse(\n      {\n        success: false,\n        error: message,\n        code,\n        timestamp: new Date().toISOString()\n      },\n      status\n    );\n  },\n\n  /**\n   * Create validation error response\n   */\n  createValidationError(errors = [], status = 400) {\n    return this.createMockResponse(\n      {\n        success: false,\n        error: 'Validation failed',\n        validationErrors: errors\n      },\n      status\n    );\n  }\n};\n\n/**\n * DOM testing utilities\n */\nexport const domUtils = {\n  /**\n   * Wait for element to appear in DOM\n   */\n  async waitForElement(selector, timeout = 5000) {\n    return new Promise((resolve, reject) => {\n      const element = document.querySelector(selector);\n      if (element) {\n        resolve(element);\n        return;\n      }\n      \n      const observer = new MutationObserver(() => {\n        const element = document.querySelector(selector);\n        if (element) {\n          observer.disconnect();\n          resolve(element);\n        }\n      });\n      \n      observer.observe(document.body, {\n        childList: true,\n        subtree: true\n      });\n      \n      setTimeout(() => {\n        observer.disconnect();\n        reject(new Error(`Element ${selector} not found within ${timeout}ms`));\n      }, timeout);\n    });\n  },\n\n  /**\n   * Simulate user typing with delays\n   */\n  async typeWithDelay(element, text, delay = 50) {\n    for (const char of text) {\n      element.value += char;\n      element.dispatchEvent(new Event('input', { bubbles: true }));\n      await new Promise(resolve => setTimeout(resolve, delay));\n    }\n  },\n\n  /**\n   * Simulate drag and drop\n   */\n  simulateDragDrop(sourceElement, targetElement) {\n    const dragStartEvent = new DragEvent('dragstart', {\n      bubbles: true,\n      cancelable: true,\n      dataTransfer: new DataTransfer()\n    });\n    \n    const dropEvent = new DragEvent('drop', {\n      bubbles: true,\n      cancelable: true,\n      dataTransfer: dragStartEvent.dataTransfer\n    });\n    \n    sourceElement.dispatchEvent(dragStartEvent);\n    targetElement.dispatchEvent(dropEvent);\n  },\n\n  /**\n   * Mock IntersectionObserver\n   */\n  mockIntersectionObserver() {\n    global.IntersectionObserver = jest.fn(() => ({\n      observe: jest.fn(),\n      unobserve: jest.fn(),\n      disconnect: jest.fn()\n    }));\n  }\n};\n\n/**\n * Canvas/signature testing utilities\n */\nexport const canvasUtils = {\n  /**\n   * Mock HTML5 Canvas context\n   */\n  mockCanvasContext() {\n    const mockContext = {\n      clearRect: jest.fn(),\n      beginPath: jest.fn(),\n      moveTo: jest.fn(),\n      lineTo: jest.fn(),\n      stroke: jest.fn(),\n      fill: jest.fn(),\n      arc: jest.fn(),\n      rect: jest.fn(),\n      fillText: jest.fn(),\n      measureText: jest.fn(() => ({ width: 100 })),\n      drawImage: jest.fn(),\n      getImageData: jest.fn(() => ({ data: new Uint8ClampedArray(4) })),\n      putImageData: jest.fn(),\n      toDataURL: jest.fn(() => 'data:image/png;base64,mock-canvas-data'),\n      save: jest.fn(),\n      restore: jest.fn(),\n      scale: jest.fn(),\n      translate: jest.fn(),\n      rotate: jest.fn()\n    };\n    \n    HTMLCanvasElement.prototype.getContext = jest.fn(() => mockContext);\n    return mockContext;\n  },\n\n  /**\n   * Simulate signature drawing\n   */\n  simulateSignature(canvas, points = []) {\n    const defaultPoints = [\n      { x: 50, y: 50 },\n      { x: 100, y: 100 },\n      { x: 150, y: 75 },\n      { x: 200, y: 125 }\n    ];\n    \n    const signaturePoints = points.length > 0 ? points : defaultPoints;\n    \n    // Simulate mouse/touch events for signature\n    signaturePoints.forEach((point, index) => {\n      const eventType = index === 0 ? 'mousedown' : 'mousemove';\n      const event = new MouseEvent(eventType, {\n        clientX: point.x,\n        clientY: point.y,\n        bubbles: true\n      });\n      \n      canvas.dispatchEvent(event);\n    });\n    \n    // End signature\n    canvas.dispatchEvent(new MouseEvent('mouseup', { bubbles: true }));\n  },\n\n  /**\n   * Validate signature data\n   */\n  validateSignatureData(dataUrl) {\n    if (!dataUrl || typeof dataUrl !== 'string') {\n      return { isValid: false, error: 'Invalid signature data' };\n    }\n    \n    if (!dataUrl.startsWith('data:image/')) {\n      return { isValid: false, error: 'Signature data must be an image' };\n    }\n    \n    // Check if signature has actual content (not just empty canvas)\n    if (dataUrl.includes('blank') || dataUrl.length < 100) {\n      return { isValid: false, error: 'Signature appears to be empty' };\n    }\n    \n    return { isValid: true };\n  }\n};\n\n/**\n * Date/time utilities for testing\n */\nexport const dateUtils = {\n  /**\n   * Create a date string in various formats\n   */\n  createTestDate(daysFromNow = 0, format = 'iso') {\n    const date = new Date();\n    date.setDate(date.getDate() + daysFromNow);\n    \n    switch (format) {\n      case 'iso':\n        return date.toISOString();\n      case 'date':\n        return date.toISOString().split('T')[0];\n      case 'datetime-local':\n        return date.toISOString().slice(0, 16);\n      case 'us':\n        return date.toLocaleDateString('en-US');\n      default:\n        return date.toISOString();\n    }\n  },\n\n  /**\n   * Mock Date.now for consistent testing\n   */\n  mockDateNow(timestamp = 1704067200000) { // 2024-01-01 00:00:00 UTC\n    const originalNow = Date.now;\n    Date.now = jest.fn(() => timestamp);\n    \n    return () => {\n      Date.now = originalNow;\n    };\n  },\n\n  /**\n   * Create date range for testing\n   */\n  createDateRange(startDaysAgo = 7, endDaysFromNow = 7) {\n    return {\n      startDate: this.createTestDate(-startDaysAgo, 'date'),\n      endDate: this.createTestDate(endDaysFromNow, 'date')\n    };\n  }\n};\n\n/**\n * Performance testing utilities\n */\nexport const performanceUtils = {\n  /**\n   * Measure execution time\n   */\n  async measureTime(fn, name = 'operation') {\n    const startTime = performance.now();\n    const result = await fn();\n    const endTime = performance.now();\n    const duration = endTime - startTime;\n    \n    console.log(`${name} took ${duration.toFixed(2)}ms`);\n    \n    return {\n      result,\n      duration,\n      name\n    };\n  },\n\n  /**\n   * Create performance benchmark\n   */\n  async benchmark(operations, iterations = 1) {\n    const results = {};\n    \n    for (const [name, operation] of Object.entries(operations)) {\n      const times = [];\n      \n      for (let i = 0; i < iterations; i++) {\n        const { duration } = await this.measureTime(operation, `${name} iteration ${i + 1}`);\n        times.push(duration);\n      }\n      \n      results[name] = {\n        times,\n        average: times.reduce((sum, time) => sum + time, 0) / times.length,\n        min: Math.min(...times),\n        max: Math.max(...times),\n        iterations\n      };\n    }\n    \n    return results;\n  },\n\n  /**\n   * Memory usage tracking\n   */\n  measureMemory(operation, name = 'memory test') {\n    const beforeMemory = performance.memory?.usedJSHeapSize || 0;\n    const result = operation();\n    const afterMemory = performance.memory?.usedJSHeapSize || 0;\n    \n    const memoryDiff = afterMemory - beforeMemory;\n    console.log(`${name} memory usage: ${memoryDiff} bytes`);\n    \n    return {\n      result,\n      memoryUsage: memoryDiff,\n      beforeMemory,\n      afterMemory\n    };\n  }\n};\n\n/**\n * Test assertion utilities\n */\nexport const assertUtils = {\n  /**\n   * Assert API response structure\n   */\n  assertApiResponse(response, expectedFields = ['success']) {\n    expect(response).toBeDefined();\n    expect(typeof response).toBe('object');\n    \n    expectedFields.forEach(field => {\n      expect(response).toHaveProperty(field);\n    });\n  },\n\n  /**\n   * Assert error response format\n   */\n  assertErrorResponse(response) {\n    this.assertApiResponse(response, ['success', 'error']);\n    expect(response.success).toBe(false);\n    expect(typeof response.error).toBe('string');\n    expect(response.error.length).toBeGreaterThan(0);\n  },\n\n  /**\n   * Assert validation error format\n   */\n  assertValidationError(response) {\n    this.assertErrorResponse(response);\n    expect(response).toHaveProperty('validationErrors');\n    expect(Array.isArray(response.validationErrors)).toBe(true);\n    expect(response.validationErrors.length).toBeGreaterThan(0);\n  },\n\n  /**\n   * Assert date format\n   */\n  assertDateFormat(dateString, format = 'iso') {\n    expect(typeof dateString).toBe('string');\n    \n    switch (format) {\n      case 'iso':\n        expect(dateString).toMatch(/^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}/);\n        expect(new Date(dateString).toISOString()).toBe(dateString);\n        break;\n      case 'date':\n        expect(dateString).toMatch(/^\\d{4}-\\d{2}-\\d{2}$/);\n        break;\n      default:\n        expect(new Date(dateString)).toBeInstanceOf(Date);\n    }\n  }\n};\n\n/**\n * Cleanup utilities for tests\n */\nexport const cleanupUtils = {\n  /**\n   * Clean up all mocks and spies\n   */\n  cleanupMocks() {\n    jest.clearAllMocks();\n    jest.restoreAllMocks();\n    jest.clearAllTimers();\n  },\n\n  /**\n   * Reset DOM to clean state\n   */\n  cleanupDOM() {\n    document.body.innerHTML = '';\n    document.head.innerHTML = '';\n  },\n\n  /**\n   * Clean up event listeners\n   */\n  cleanupEventListeners() {\n    // Remove all event listeners from window\n    const newWindow = Object.create(window);\n    Object.setPrototypeOf(window, newWindow);\n  },\n\n  /**\n   * Complete cleanup for test isolation\n   */\n  fullCleanup() {\n    this.cleanupMocks();\n    this.cleanupDOM();\n    \n    // Clear any test data\n    if (global.testData) {\n      global.testData = {};\n    }\n    \n    // Reset console (in case it was mocked)\n    if (console._originalLog) {\n      console.log = console._originalLog;\n    }\n  }\n};\n\n// Default export with all utilities\nexport default {\n  dbUtils,\n  authUtils,\n  fileUtils,\n  apiUtils,\n  domUtils,\n  canvasUtils,\n  dateUtils,\n  performanceUtils,\n  assertUtils,\n  cleanupUtils\n};